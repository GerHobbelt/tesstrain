; (C) Copyright 2021, Bartlomiej Uliasz
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
; http://www.apache.org/licenses/LICENSE-2.0
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.

#include _console.ahki
#include _quick_sort.ahki

; ----------------
; STRING FUNCTIONS
; ----------------

StrCutEnd(text, numberOfCharacters) {
	return SubStr(text, 1, -numberOfCharacters)
}

StrRCutTo(text, cutStartStr) {
	cutIndex := InStr(text, cutStartStr,,, -1)
	if (!cutIndex) {
		return text
	}
	return SubStr(text, cutIndex + StrLen(cutStartStr))
}

StrEndsWith(text, ending) {
	return SubStr(text, -StrLen(ending)) == ending
}


; ---------------
; ARRAY FUNCTIONS
; ---------------

ArrayContains(_array, itemToFind) {
	for (item in _array) {
		if (item == itemToFind) {
			return true
		}
	}
	return false
}

ArrayTransform(arr, method, argument) {
	ret := []
	for (element in arr) {
		ret.Push(method(element, argument))
	}
	return ret
}

ArrayForEach(arr, Callback) {
	for (item in arr) {
		Callback(item)
	}
}

ArrayJoin(arr, joinWith:=" ") {
	ret := ""
	for element in arr {
		if (A_Index > 1) {
			ret .= joinWith element
		} else {
			ret .= element
		}
	}
	return ret
}

ArrayHead(arr, headLength) {
	headArray := []
	remaining := headLength

	for (item in arr) {
		if (remaining <= 0) {
			break
		}
		headArray.Push(item)
		remaining -= 1
	}

	return headArray
}

ArrayTail(arr, tailLength) {
	tailArray := []
	if (arr.Length <= tailLength) {
		return arr
	}

	skip := arr.Length - tailLength
	for (item in arr) {
		if (skip <= 0) {
			tailArray.Push(item)
		} else {
			skip -= 1
		}
	}

	return tailArray
}

ArrayPushAll(source, target) {
	for (item in source) {
		target.Push(item)
	}
}

ArraySort(arr, func:="") {
	if (arr.Length == 0) {
		return []
	}
	if (!func && !IsNumber(arr[1])) {
		func := StrCompare
	}
	return QuickSort(arr, func)
}


;----------------------
; MAP FUNCTIONS
;----------------------

MapSafeDelete(_map, _key) {
	if (_map.Has(_key)) {
		_map.Delete(_key)
	}
}


;----------------------
; FILE SYSTEM FUNCTIONS
;----------------------

FileSave(fileName, content) {
	myFile := FileOpen(fileName, "w")
	myFile.Write(content)
	myFile.Close()
}

FindAllFiles(pattern) {
	filesFound := []
	loop Files, pattern {
		filesFound.Push(A_LoopFileFullPath)
	}
	return filesFound
}

FindAllFilesExtended(pattern) {
	filesFound := []
	loop Files, pattern {
		filesFound.Push({path: A_LoopFileFullPath, modified: A_LoopFileTimeModified})
	}
	return filesFound
}

FileGetFirstLine(filePath) {
	return GetFileLine(filePath, 1) 
}

GetFileLine(filePath, lineNumber) {
	savedLine := ""
	loop read, filePath {
		if (A_Index == lineNumber) {
			savedLine := A_LoopReadLine  ; When loop finishes, this will hold the last line.
			break
		}
	} else {
		throw Error("File '" filePath "' not found")
	}

	return savedLine
}

; Removes path leaving only file name with extension
; Alternatively 'SplitPath' AHK command may be used
FileGetName(filePathWithName) {
	return StrRCutTo(filePathWithName, "\")
}

IsFileOlder(file1, file2) {
	return StrCompare(FileGetTime(file1), FileGetTime(file2)) < 0
}


; ----------------------
; OTHER HELPER FUNCTIONS
; ----------------------

GetNonEmptyLines(filePath) {
	lines := []
	loop read, filePath {
		line := Trim(A_LoopReadLine)
		if (line != "") {
			lines.Push(line)
		}
	}
	return lines
}

CmdLogAppend(text) {
	FileAppend text, "command.log"
}

OcrImageFile(imageFullPath, lang:="") {
	ocrOutput := ExecuteCommand(BINARIES["tesseract"] " `"" imageFullPath "`" -"
		. (lang ? " -l " lang : "")
		. " --psm 13 -c page_separator= --tessdata-dir " TESSDATA)
	return Trim(ocrOutput.StdOut, "`t`n`r ")
}

ProgressStatusGui(newStatus:="", ownerGui:="", windowTitle:="Training progress") {
	static lastStatus := "", statusGui := "", ownedBy := ""

	if (!newStatus && statusGui) {
		if (ownedBy) {
			ownedBy.Opt("-Disabled")
		}
		statusGui.Destroy()
		lastStatus := statusGui := ownedBy := ""
		return
	}

	if (!statusGui) {
		statusGui := Gui("+Resize", windowTitle)
		if (ownerGui) {
			statusGui.Opt("+Owner" ownerGui.Hwnd)
			ownerGui.Opt("+Disabled")
			ownedBy := ownerGui
		}
	}

	if (lastStatus) {
		lastStatus.Text := "Done"
	}
	statusGui.Add("Text", "section xm w400", newStatus)
	lastStatus := statusGui.Add("Text", "ys w40", "...")
	statusGui.Show("AutoSize")
}

VerifyRequirements() {
	ProgressStatusGui("Starting up",, "Tesstrain GUI")
	
	VerifyPythonDependencies()
		
	ProgressStatusGui()
	return true
}

VerifyPythonDependencies() {
	ProgressStatusGui("Verifying installed Python version")
	try {
		version := ExecuteCommand("python --version")
		PYTHON_EXE := "python"
	} catch Error as ePython {
		try {
			version := ExecuteCommand("python3 --version")
			PYTHON_EXE := "python3"
		} catch Error as ePython3 {
			MsgBox("Executing 'python' command returned error: " ePython.Message "`n`n"
				. "Executing 'python3' command returned error: " ePython3.Message "`n`n"
				. "Please make sure that you have a Python 3.x installed and that "
				. "'python.exe' or 'python3.exe' executable file directory is in your PATH environment variable.")
			ExitApp()
		}
	}

	versionStr := StrRCutTo(Trim(version.StdOut, "`t`n`r "), " ")
	versionArray := StrSplit(versionStr, ".")
	if (versionArray.Length < 1 || !IsInteger(versionArray[1]) || versionArray[1] < 3) {
		MsgBox("Wrong Python version. Returned version: '" versionStr "'. Please install Python version 3 or above.")
		ExitApp()
	}
	
	ProgressStatusGui("Verifying/installing required Python modules")

	try {
		ExecuteCommand(PYTHON_EXE " -m pip install Pillow>=6.2.1 python-bidi>=0.4 matplotlib pandas")
	} catch Error as e {
		if (YesNoConfirmation("Could not install required Python modules. Probably you don't have required privilages.`n"
			. "Do you want me to try again as Administrator?")) {
			ExecuteCommand(PYTHON_EXE " -m pip install Pillow>=6.2.1 python-bidi>=0.4 matplotlib pandas",, true)
			ExecuteCommand()
		} else {
			MsgBox("Error installing required Python modules.`n" e.Message)
			ExitApp()
		}
	}
}

YesNoConfirmation(message) {
	return MsgBox(message,, "YesNo Icon! 0x40000") == "Yes"
}

MsgBoxAot(message) {
	MsgBox(message,, 0x40000)
}

OnError MyErrorFunction
MyErrorFunction(_exception, _mode) {
    MsgBox(DescribeException(_exception) "`nMode: " _mode)
    ExitApp	; It's an unhandled exception. We want to Shutdown the app.
}

DescribeException(e) {
	extra := e.HasProp("Extra") ? e.Extra : ""
	return "Exception: " e.Message " in " e.What " at " e.File ":" e.Line
		.  (extra ? "`nAdditional information (e.Extra):`n" extra : "")  "`n`n"
		. CallStack(2)

	CallStack(startOffset:=0, maxLevels:="") {
		if (A_IsCompiled) {
			return
		}

		ret := ""
		indent := "`t"
		loop {
			if (maxLevels && A_Index > maxLevels) {
				break
			}
			offset := -(A_Index + startOffset)
			e := Error(".", offset)
			if (e.What == offset) {
				break
			}
			fileName := ""
			SplitPath e.file, &fileName
			ret .= "[" (offset + startOffset) "]" fileName "(" e.Line "):`n"
					. indent Trim(GetFileLine(e.file, e.line)) "`n"
			ret .= "`t=> " e.What "`n"
		}

		return ret
	}
}

DisableSystemStandby(shouldDisable) {
	static oldState:=0
	newState := shouldDisable ? 0x80000001 : 0x80000000
	if (newState != oldState) {
		DllCall("SetThreadExecutionState", "UInt", newState)
		oldState := newState
	}
}
